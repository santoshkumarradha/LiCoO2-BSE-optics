      program bethesalpeter

      use m_readeigen,only: init_readeigen,init_readeigen2,readeval
      use m_readqg, only: iqindx2qg,init_readqg
      use m_read_bzdata, only: read_bzdata,
     &     ginv,nqbz,wibz,qibz,nqibz,qbz,irk,ngrp,nstar,wbz,qbas
      use m_genallcf_v3, only: genallcf_v3,
     &     plat,alat,nspin,natom,iclass,z,nl,konf,nclass,esmr,nlmto,
     &     symgg,pos,icore,ncore,nnc,nlnmx,nlnmv,nlnmc,nctot,nn,il,
     &     in,im,nlnm,invg,ef,niw
      use keyvalue,only: getkeyvalue
      use omp_lib
      use mpi_mod, rank=> mpi_rank

      implicit none

      real(8):: rydberg,min_diagval,qlatinv(3,3),omg_c,fac2
      integer :: absorp_file,ngvec_qsub,Hmax3,q_index,num_q,ifrcw,
     .          mu_ind,iw,nu_ind,ifrcwi,ifrcwB,ifrcwiB,inds,
     .          switchr,dum1,dum2,memtol,invrot,mat_rnk,
     .          nq0,iq0,ifidmlx,lxklm,nlxklm,ifw0w0i2,ifw0w0i,ircw,
     .          ifrcwx,nq0i,ifrcw2,ifrcwi2,ifepsfile,ifepsfileI,
     .          ifepsfilesmall,ifepsfileIsmall,Hmax_opt,Hmax_ini
      real(8),allocatable:: absorp(:),omega(:), occdiff(:),occs(:,:,:),
     & evals(:),evals2(:),Vcousq(:),freq_i(:),freqx(:),wx(:),expa(:),
     & HdiagIP(:),occdiffIP(:),real_eps(:),wtl(:,:),freq_r(:),
     & dmlx(:,:),epinvq0i(:,:),epinv(:,:,:),wklm(:)

      complex*16,allocatable::eigvalH(:,:),zw(:,:),eigvecH(:,:,:),
     &  overlapH_inv(:,:),rho0(:),eps_inv(:,:),eps_inv2(:,:),zw2(:,:),
     &  Hdiag(:),H2p(:,:),llw(:,:),llwI(:,:)
      complex*16,allocatable :: tmp1(:),tmp3(:),epstilde(:,:),epstildesmall(:,:)
C     Outputs generated by w0w0i
      complex(8),allocatable :: w0(:),w0i(:)
      complex(8) :: llmat(3,3)

      complex*16 :: sum_overS,sum_overSp,sum_overlp,rho0t,
     &          sumabsorp,fac1,eps11,eps11BSE,fac,tocomp,tocomp2,Pmod
      real(8):: pi, fpi, cell_vol, fpi_o_vol,vol,xxx(3,3),
     &        deltaomg,max_omega,min_omega,energy_scale,qvec(3),vc1
      complex*16,parameter ::zimag =(0d0,1d0), z_one=(1d0,0d0)
      integer::nw, incwfin,nw_max,nw_min,nw_i,nwp,ix ! For genallcf
      real(8)::efin,ntot,nocctotg2_bc,qsub(3),quu(3),det,ua=1d0
      integer::wind,lambind,lambindp,sind,sindp,ngb,q_start,szk2,
     &         valind,condind,k_ind,numkpts,kqindx,kqindx_ibz,npm,
     &         q_end,iphon,ntphon,ifiphon,ret,itx,itl,ary
      logical::Hermit_H,legas,rst_from_krn,kernfile,rst_from_diag,
     &         diagfile,QSGW_BSE,new_kern,restart_withq,TimeReversal,
     &          EELS_calc,Gauss_BSE,Chi_RIXS,x0_small,Chi_dir

      integer:: numomega,Smax,Hmax,iftote2(2),nqTOTE,ntqTOTE,
     &          ia,ic,is,is2,k_ind_ibz,nband,ibasx,ibas,num_valn_file,
     &          valn_default_st,valn_default_end,num_valn,num_valn_tmp,
     &          cond_default_st,cond_default_end,num_cond_states,ind1,
     &          ig,k_indfbz,nblochpmx,Hmax2,ind2,iopenxx,bandindTOTE,
     &          kindTOTE,check_ind,nxx,ind3,img_frqs
      real(8):: valn,esmref,efnew,ef2,ImagE1,ImagE2,qvecsize,Gauss_CO
     &        ,rho0t2(3),ImagE,ef_eV,qTOTE(3),qsub_kern(3),imagEs
      real(8),allocatable :: EDFT(:,:,:),E_GWZ(:,:,:),E_GW(:,:,:),
     &           Zfac(:,:,:),qp_opt(:,:),Vcoud(:)
      integer, allocatable :: ibzx(:),nphon(:),num_val_sp(:),
     .      num_valnsp(:),num_cond_statessp(:),valn_default_stsp(:),
     . valn_default_endsp(:),cond_default_stsp(:),cond_default_endsp(:),
     . Smax_sp(:)

      real(8),allocatable::   wqt(:),q0i(:,:)

C integers for reading and writing to files!
      integer,parameter :: NULLI=-99999
      integer :: ifhbed,nprecb,mrecb,mrece,i,mrecg,ifwd,nprecx,mrecl

      complex(8),allocatable ::kernel(:,:),kernel2(:,:)
C     space group information
      integer,allocatable :: iclasst(:), invgx(:), miat(:,:),ieaord(:)
      real(8),allocatable    :: tiat(:,:,:),shtvg(:,:)

      integer nthreads,omppid,iopen,iclose
      real(8):: cpusec,walltime0,dwtime
      logical:: MPIinitexists,Independent_particle,G0W0_noZ

C for reading optical matrix
      integer :: ifi,nfilm,nempm,nspx,nkp_opt,ndham_opt,nsp_opt
      real(8) :: efermi_opt
      real(8),allocatable :: evals_opt(:,:,:),optmt(:,:,:,:,:)
      complex(8),allocatable :: optmt2(:,:,:,:,:),zzmeltppovlz(:,:),
     .          Pbar(:,:),OVLPbar(:,:),Pright(:,:),PrightRPA(:,:),
     .          eps_new(:,:)
      logical :: opt_abs,NL_fieldcorr,conv_bnds
      character(5) :: charnum5
      integer :: nfilo, nfiup, nemlo, nemup
      procedure(real(8)):: tripl

      npm = 1
      IF(.not.TimeReversal())npm=2

C        if(npm==2)call rx('Bethe-Salpeter currently only written for
C     . T.R.S. on')
      call mpi_start
      walltime0 = dwtime()
C$OMP parallel
      nthreads = omppid(0)
C$OMP end parallel
      call cputid(0)

      if (rank == 0) then
        inquire(file='MPI.init',EXIST=MPIinitexists)
        if (MPIinitexists) then
          open(100,file="MPI.init", err=1234 )
          read(100,*) mpi_N1, mpi_N2
          close(100)
        else
          mpi_N1 = mpi_size
          mpi_N2 = 1
        endif
      endif
#ifdef USE_MPI
      call MPI_Bcast(mpi_N1, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mpi_N2, 1, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif
1234  continue
#ifdef USE_MPI
      if(rank == 0) write(6,*) "MPI initialization done."
#endif
      call getkeyvalue("GWinput","Conv_bands",conv_bnds,
     & default=.false.)
       call getkeyvalue("GWinput","x0_small_BSE",x0_small,
     & default=.false.)
        call getkeyvalue("GWinput","Chi_dir_BSE",Chi_dir,
     & default=.false.)
        if(.not.x0_small)Chi_dir=.false.
      call getkeyvalue("GWinput","Chi_RIXS",Chi_RIXS,
     & default=.false.)
      call getkeyvalue("GWinput","Tamm-Dancoff",Hermit_H,
     & default=.true.)
      call getkeyvalue("GWinput","Gauss_BSE",Gauss_BSE,
     & default=.false.) ! Gaussians, if not then Lorentzian
      call getkeyvalue("GWinput","MemoryTol_Diag",memtol,
     & default=32600) ! When diagonalising ZHEEV takes quite some time, however ZHEEVD is much quicker.  ZHEEVD, however, requires about 3 times more memory.

C        if(.not.Hermit_H)call rx('Bethe-Salpeter currently only written
C     . for Tamm-Dancoff approx on')

      if(rank == 0) INQUIRE (FILE='LEGAS',EXIST=legas)
      if(legas) call rx('bethe salpeter not implemented for legas=T')

      pi = 4.0d0*datan(1.0d0)
      fpi = 4.0d0*pi
      energy_scale = 1.0d0 ! ensure energy scale is the same as readevals, Rydberg or Hartree=2Rydberg?

      call getkeyvalue("GWinput","QSGW_BSE",QSGW_BSE,
     & default=.true.)                                  ! Probably really only required if using RPA GW(or QSGW) data for optical spectra
       call getkeyvalue("GWinput","G0W0_noZ",G0W0_noZ,
     & default=.false.)                                  ! Probably really only required if using RPA GW(or QSGW) data for optical spectra
      call getkeyvalue("GWinput","EELS",EELS_calc,
     & default=.false.)                                  ! Probably re

      write(*,*) 'Enter mode:'
      write(*,*) '-1 Independent particle optical absorption spectra'
      write(*,*) ' 0 BSE optical absorption spectrum'
      write(*,*) ' 3 Calculate screened Coulomb interaction for all q'

      call getjobmode(switchr)
      if (switchr == NULLI) then
        write(*,*) 'If the code crashes here, you are trying to run it',
     .    'without piping in an input, i.e., echo mode | /pathtoexcecutable'
        call readin5(switchr,dum1,dum2)
      endif

      if (switchr==1.or.switchr==2.or.switchr==0.or.switchr==-1) opt_abs=.true.
      if (switchr==1.or.switchr==-1) independent_particle=.true.
      if (switchr==2.or.switchr==0.or.switchr==3) independent_particle=.false.
      if (switchr==3) opt_abs=.false.

      call getkeyvalue("GWinput","ImagEner1",ImagE1,
     & default=0.02d0)! In Rydbergs, Broadening
      call getkeyvalue("GWinput","ImagEner2",ImagE2,
     & default=10000000.0d0)! In Rydbergs
      call getkeyvalue("GWinput","Gauss_cutoff",Gauss_CO,
     & default=0.0d0)! In Rydbergs, Broadening


      if(ImagE2>1000000.0d0)ImagE2 = ImagE1
C Should maybe use the same broadening as that used in
C hx0fp0.sc.m.F??

      nw = 0  ! number of frequencies. WILL read from file, if nw=0
      efin = -999d0 ! -999d0 => WONT read from file. If =1, then read from EFERMI
      incwfin = 0 ! see from line 223 in genallcf_v3 module??? if -1 or 0 then ncore=0
C----------------------------------------------------------------------
      call read_BZDATA( )

      call genallcf_v3(nw,efin,incwfin)
C      call dinv33(plat,1,xxx,vol) ! 0=>inverse, 1=>transpose of inverse
C      cell_vol = dabs(vol)*(alat**3) ! 8pi**3 ? In Bohr
      cell_vol = abs(alat**3*tripl(plat,plat(1,2),plat(1,3)))
        write(*,*)'Cell volume in a.u.=',cell_vol
      if (rank == 0) then

      ifhbed = iopen('hbe.d',1,0,0)
      read (ifhbed,*) nprecb,mrecb,mrece,i,i,nband,mrecg
      if (nprecb == 4) call rx('bethesalpter: b,hb must be double
     & precision')
      i=iclose('hbe.d')
      endif

#ifdef USE_MPI
      call MPI_Bcast(nprecb, 1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mrecb,  1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mrece,  1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(nband,  1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
      call MPI_Bcast(mrecg,  1,  MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif

      call init_readeigen(ginv,nspin,nband,mrece) !initialization of...
      call init_readeigen2(mrecb,nlmto,mrecg)

C
C can now call readeval(q,isp,ev) i.e. the eigenvalues for a given q and spin
C efsimplef2a to determine fermi level????? Can read from EFERMI, but
C what about occupations? Currently using occupations, however the norm
C seems to be to allow the occupations to be one or zero
C (insulators/semic?).
C
C --- Get space group information ---
C     Need true class information in order to determine the space group
C     because the class in the generated GW file is dummy.(iclass(ibas)=ibas should be kept).
      allocate(iclasst(natom),invgx(ngrp),miat(natom,ngrp),
     & tiat(3,natom,ngrp),shtvg(3,ngrp))
      if(rank == 0) then
       open (102,file='CLASS')
       do ibas = 1,natom
         read(102,*) ibasx, iclasst(ibas)
          write(6, "(2i10)") ibasx, iclasst(ibas)
       enddo
      endif
      CLOSE(102)
#ifdef USE_MPI
     call MPI_Bcast(ibasx,  1,     MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
     call MPI_Bcast(iclasst,natom, MPI_INTEGER, 0, MPI_COMM_WORLD, ierror)
#endif

C     Get space-group transformation information. See header of mptaouof.
      call mptauof(symgg,ngrp,plat,natom,pos,iclasst,miat,tiat,invgx,
     & shtvg )
C symgg is matrix that changes x,y,z to x,y,z -x,-y,-z x,z,y etc (48 ops for
C cubic symmetry). miat tells which atom is being mapped to which atom
C for the particular symop. tiat is the actual shift. pos(:,miat(:,ig))+tiat(:,:,ig) is new position.
C pos(:,miat(:,ig))+tiat(:,:,ig) = symgg(:,:,ig)*pos(:,:)+shtvg(:,ig)!
C shtvg is the a_i in Eq.(47) of PRB81 125102
C invgx tells which element in symgg is its inverse, e.g., if invgx(3)=5 then inv(symgg(:,:,3))=symgg(:,:,5)
C ---------------------------------------------------------------------
C
      esmref=esmr
      call efsimplef2a(nspin,wibz,qibz,ginv,nband,nqibz,
     .  konf,z,nl,natom,iclass,nclass,
     .  valn, legas, esmref, !!! valn is input for legas=T, output otherwise.
     .  qbz,nqbz,efnew) ! Just read in from EFERMI?
      ef2=efnew
      write(*,*)'Number of valence electrons=',valn
      write(*,*)'FERMI LEVEL from efsimplef2a=',ef2
      allocate(occs(nqbz,nspin,nband)) ! Not so sure if these are needed, usually in the literature occupations are either 0 or 1 in BSE formulation
      ntot = nocctotg2_bc(nspin,ef2,esmr,qbz,wbz,nband,nqbz,occs) ! Spin included in occupations

      allocate(num_val_sp(nspin)) ! Number of valence electrons per spin
      do ind1=1,nspin
        do ind2=1,nband
           if(occs(1,ind1,ind2) <= 0.5d0)then
             num_val_sp(ind1)=ind2-1
             exit
           endif
        enddo
      enddo

      do ind1=1,nspin
      write(*,*)'valence electrons for spin',ind1,'=',num_val_sp(ind1)
      enddo
CCCCCCCCCCCCCCCCCCC-------------------------------------------------
C
C  Note the occs are determined from LDA(or DFT for QSGW). Cases like
C  Ge, with a negative LDA B.G. may cause occs to be calculated wrongly!
C
CCCCCCCCCCCCCCCCCCC-------------------------------------------------

C      Number of valence states used in BSE may be less than number of valence states
      allocate(num_valnsp(nspin),num_cond_statessp(nspin))
      allocate(valn_default_stsp(nspin),valn_default_endsp(nspin),
     .  cond_default_stsp(nspin),cond_default_endsp(nspin),
     .  Smax_sp(nspin))
      call getkeyvalue("GWinput","NumValStates",num_valnsp(1),
     & default=num_val_sp(1))
      call getkeyvalue("GWinput","NumCondStates",num_cond_statessp(1),
     & default=0)
      IF(Num_cond_statessp(1)==0)then
      WRITE(*,*)'Im only using 4 conduction states as you have not
     .  specified this in the input file)'
        num_cond_statessp(1) = 4
      ENDIF
      if(nspin==2)then
      call getkeyvalue("GWinput","NumValStates2",num_valnsp(2),
     & default=100001)
        IF(num_valnsp(2)==100001.and.num_valnsp(1) /= num_val_sp(1))
     &  num_valnsp(2)=num_valnsp(1)
        IF(num_valnsp(2)==100001.and.num_valnsp(1)==num_val_sp(1))
     &  num_valnsp(2)=num_val_sp(2)
      if(num_valnsp(2)>num_val_sp(2))num_valnsp(2)=num_val_sp(2)
      call getkeyvalue("GWinput","NumCondStates2",num_cond_statessp(2),
     & default=num_cond_statessp(1))
      endif

      DO ind1=1,nspin
      valn_default_stsp(ind1) = num_val_sp(ind1)-num_valnsp(ind1)+1
      valn_default_endsp(ind1) = num_val_sp(ind1)
      cond_default_stsp(ind1) = num_val_sp(ind1) + 1
      cond_default_endsp(ind1)=cond_default_stsp(ind1)+
     .                          num_cond_statessp(ind1)-1
      Smax_sp(ind1) = num_valnsp(ind1) * num_cond_statessp(ind1)*nqbz
      ENDDO

C-----------------------------------n-----------------------------------

      numkpts = nqbz    ! or nqibz and use wibz?

      Smax=sum(Smax_sp)
      Hmax = Smax
      write(*,*)'Smax=',Smax
      allocate(ibzx(nqbz))
      call invkibzx(irk,nqibz,ngrp,nqbz,ibzx) ! Gives corresponding point in IBZ.  Point i in FBZ, then ibzx(i)=the i in the IBZ
C
      IF(QSGW_BSE)allocate(evals(nband),evals2(nband))

      IF(npm==1)THEN
        if(Hermit_H)then
          allocate(occdiff(Hmax))
        else
          allocate(occdiff(2*Hmax))
        endif
      ELSE
        if(opt_abs)then
          allocate(occdiff(Hmax))
        else
          allocate(occdiff(2*Hmax))
        endif
      ENDIF

C Indices: k(1),spin(1),valn(1),cond(1)
C          k(1),spin(1),valn(1),cond(2), etc!

      call getkeyvalue("GWinput","NLF_corr_BSE",NL_fieldcorr,
     & default=.false.)! Non-local field correction for optical absorption (can also be handled using MEFAC=2 in OPTICS category in ctrl file)

      IF(QSGW_BSE.and.opt_abs.and.NL_fieldcorr.and.switchr <= 0)
     .          INQUIRE(FILE='0run/TOTE.UP',EXIST=QSGW_BSE)
      IF(QSGW_BSE.and.opt_abs.and.NL_fieldcorr.and.switchr>0)
     .          INQUIRE(FILE='0run/TOTE.UP',EXIST=NL_fieldcorr)
      IF(.NOT.QSGW_BSE)WRITE(*,*)'Have you specified
     .that you want G0W0+BSE in the GWinput?'

C We read the LDA eigenvalues to account for N.L. fields in optical
C absorption. If G0W0 then
C are read from the directory and NOT the sub-directory '0run'
      IF(QSGW_BSE.and.opt_abs.and.NL_fieldcorr)THEN
      iftote2(1) = iopenxx('0run/TOTE.UP')
      if(nspin==2)iftote2(2) = iopenxx('0run/TOTE.DN')
      ELSEIF(.not.QSGW_BSE)THEN
      iftote2(1) = iopenxx('TOTE.UP')
      if(nspin==2)iftote2(2) = iopenxx('TOTE.DN')
      ENDIF

      IF(QSGW_BSE.and..not.opt_abs)THEN ! TOTE file is used if G0W0 energies are used and/or we need the DFT eigenvalues to account for N.L. field corrections for optical absorption after the QSGW calculation
      ELSEIF(QSGW_BSE.and.opt_abs.and..not.NL_fieldcorr)THEN
      ELSE

        DO is = 1, nspin
          read(iftote2(is),*)nqTOTE,ntqTOTE,ef_EV
          IF(nqTOTE/=nqibz)CALL rx('number of k in IBZ differs in
     .                          TOTE file')
        END DO

        ALLOCATE(EDFT(nqTOTE,ntqTOTE,nspin))
        ALLOCATE(E_GWZ(nqTOTE,ntqTOTE,nspin))
        ALLOCATE(E_GW(nqTOTE,ntqTOTE,nspin))
        ALLOCATE(ZFac(nqTOTE,ntqTOTE,nspin))
        check_ind = 0
        DO is = 1, nspin
          DO ind1 = 1, nqTOTE
             DO ind2 = 1, ntqTOTE

          read(iftote2(is),*)qTOTE(1:3),bandindTOTE,kindTOTE,EDFT(ind1,
     .          ind2,is),E_GWZ(ind1,ind2,is),E_GW(ind1,ind2,is),
     .          Zfac(ind1,ind2,is)
         IF(.NOT.QSGW_BSE.and.is==1.and.ind1==1)THEN
         IF(abs(Zfac(ind1,ind2,is)-1.0d0) <= 1E-7)check_ind=check_ind+1
         ENDIF
             END DO
        if(check_ind==ntqTOTE.and..not.G0W0_noZ)call rx('Zfac not
     .included in GW energies, cannot do G0W0+BSE')
          ENDDO
        ENDDO
        WRITE(*,*)'LDA energies read in'
        EDFT=EDFT/Rydberg()
        IF(QSGW_BSE)THEN
           DEALLOCATE(E_GWZ)
        ELSE
           E_GWZ = E_GWZ/Rydberg()
           if(G0W0_noZ)E_GWZ = E_GW/Rydberg()
       ENDIF
        DEALLOCATE(E_GW,Zfac)
        CLOSE(iftote2(1)); if(nspin==2)CLOSE(iftote2(2))
        ef_EV = ef_EV/Rydberg()
          WRITE(*,*)'Fermi level from TOTE file=',ef_EV
        IF(.NOT.NL_fieldcorr)deallocate(EDFT)
       ENDIF

C----------------------------------------------------------------------
C
C       Loop over q
C
C---------------------------------------------------------------------
      num_q = 1 ! optical absorption, q=0
      open(unit=7852,file='Q0P',form='formatted')
        read(7852,*)nq0i
        allocate( wqt(1:nq0i),q0i(1:3,1:nq0i) )
        do i=1,nq0i
          read (7852, * ) wqt(i),q0i(1:3,i)
        enddo
      CLOSE(7852)
      if(.not.opt_abs)num_q=nqibz+nq0i
        IF(independent_Particle)Hermit_H=.true.

           call getkeyvalue("GWinput","RestartwithKernel",rst_from_krn,
     & default=.false.)
         call getkeyvalue("GWinput","RestartwithDiagonal",rst_from_diag,
     & default=.false.)

C     call dinv33(qbas,0,qlatinv,det)
      call minv33(qbas,qlatinv)
      call getsrdpp2(nclass,nl,nxx) ! nx read from file, and nxx is its maximum value (used in kernel.F)

      q_start = 1
      q_end = num_q

      IF(.not.opt_abs)then
        INQUIRE(FILE='restart_q',EXIST=restart_withq)
        IF(restart_withq)then
        open(unit=7854,file='restart_q',form='formatted')
        rewind 7854
        read(7854,*)q_start
        read(7854,*)q_end
        close(7854)
        endif
      ENDIF
      if(q_start>nqibz+1)q_start=nqibz+1  ! Keep all calculations for q->0 together
      if(q_start <= nqibz.and.q_end>nqibz.and.q_end /=
     .  num_q)q_end=nqibz
C        q_end=num_q

      if(q_start>num_q)q_start=1 ! Previous calculation, the last index written will be num_q
      if(q_end>num_q)q_end=num_q
C------------------------------------------------------------------------
C
C               Big loop over q! Should be easily parallelisable!
C
C------------------------------------------------------------------------
      if(q_start>q_end)q_start=q_end
      if(conv_bnds)q_end=1
      DO q_index = q_start, q_end

        WRITE(*,*)'q-point ',q_index,' of ',num_q

      if(q_index <= nqibz)qsub = qibz(:,q_index)
      if(q_index>nqibz)qsub=q0i(:,q_index-nqibz)
      call getngvec('QGpsi',qsub,qlatinv,quu,ngvec_qsub) ! Needed to call to find index of k+q below

      allocate(Hdiag(size(occdiff))) ! either Smax or 2Smax

      sind=0

      DO is = 1,nspin
      do k_ind = 1, numkpts

        k_ind_ibz = ibzx(k_ind)

        IF(QSGW_BSE)call readeval(qbz(:,k_ind),is,evals)

        is2 = is
C Spin-flip
C        DO is2=1,nspin
        IF(QSGW_BSE)call readeval(qbz(:,k_ind)+qsub,is2,evals2)

            do valind = valn_default_stsp(is), valn_default_endsp(is)
               do condind = cond_default_stsp(is),cond_default_endsp(is)! increment over the conduction states first!

               Sind = Sind + 1
        kqindx = k_ind
        call iqindx2qg(qbz(:,k_ind)+qsub,1,kqindx,quu)
        kqindx_ibz = ibzx(kqindx)
        if(kqindx>nqbz)kqindx=k_ind ! for q->0, really just affects occupations
        IF(QSGW_BSE)THEN
           Hdiag(Sind) = evals2(condind)-evals(valind)
           if(size(Hdiag)>Smax)Hdiag(Sind+Smax) =
     .                  evals2(valind)-evals(condind)
        ELSE
           Hdiag(sind) = E_GWZ(kqindx_ibz,condind,is2) -
     .                   E_GWZ(k_ind_ibz,valind,is)
           if(size(Hdiag)>Smax)Hdiag(sind+Smax) =
     .                   E_GWZ(kqindx_ibz,valind,is2) -
     .                   E_GWZ(k_ind_ibz,condind,is)
        ENDIF

                  occdiff(Sind) = occs(kqindx,is2,condind) -
     &                            occs(k_ind,is,valind)!
                  if(size(Hdiag)>Smax)occdiff(Sind+Smax) =
     &             occs(kqindx,is2,valind) - occs(k_ind,is,condind)!

               end do
            end do
C Spin-flip
C        enddo
         end do
         end do
        min_diagval = minval(real(Hdiag(1:Smax)))
        write(*,*)'Min RPA Evalue=',min_diagval
      write(*,*)'Diagonal part determined'
C       MPI_BCAST....
C----------------------------------------------------------------------

C end of the part where we just consider the diagonal part
C--------------------------------------------------------------

C The kernel takes a lot of time to calculate.  We can restart with it read in from a previous run!
      mat_rnk=1
      if(npm==2.and.Hermit_H)mat_rnk=2
      if(npm==1.and..not.Hermit_H)mat_rnk=2
      if(npm==2.and..not.Hermit_H)mat_rnk=4

      new_kern= .false.
      Hmax2=Hmax
      IF(.NOT.Independent_particle)THEN
      if (rank == 0) then
        ifwd = iopen('WV.d',1,-1,0)
        read (ifwd,*) nprecx,mrecl,nblochpmx
        ifwd = iclose('WV.d')
      endif

      kernfile = .false.
      diagfile = .false.

      if(rst_from_krn) INQUIRE(FILE='kern_out',EXIST=kernfile)

      if(rst_from_krn.and.kernfile)then
       open(4692,FILE='kern_out',form='unformatted')
          rewind 4692
          read(4692)qsub_kern
          if(abs(qsub_kern(1)-qsub(1))>1E-7.or.
     .  abs(qsub_kern(2)-qsub(2))>1E-7.or.
     .  abs(qsub_kern(3)-qsub(3))>1E-7)kernfile=.false.
          read(4692)num_valn_file
          if(num_valn_file/=num_valnsp(1))kernfile=.false.
          read(4692)Hmax2,Hmax2
          if(Hermit_H.and.Hmax2/=Smax)kernfile=.false.
          if(.not.Hermit_H.and.Hmax2/=2*Smax)kernfile=.false.
          if(.not.kernfile) close(4692)
      endif
      write(*,*)'kernel read in from previous run? =', kernfile
      Hmax2=Hmax

C       if(.not.Hermit_H)Hmax2=2*Hmax
C      if(Hermit_H.and.npm==2)then
C        allocate(kernel2(Hmax2,Hmax2)) ! If we are at the Tamm-Dancoff approx & DONT have T.R.S. then we need to diagonalise two matrices
C        szk2 = Hmax2
C      else
        allocate(kernel2(1,1))
        szk2 = 1
C      endif
        kernel2 = 0d0
      if(rst_from_krn.and.kernfile)then

        if(rst_from_diag)
     .       INQUIRE(FILE='diag_out',EXIST=diagfile)

        if(diagfile)then
         open(4697,FILE='diag_out',form='unformatted')
          rewind 4697
          read(4697)qsub_kern
          if(abs(qsub_kern(1)-qsub(1))>1E-7.or.
     .  abs(qsub_kern(2)-qsub(2))>1E-7.or.
     .  abs(qsub_kern(3)-qsub(3))>1E-7)diagfile=.false.
          read(4697)Hmax3
          if(Hermit_H.and.Hmax3/=Hmax)diagfile=.false.
          IF(.NOT.HERMIT_H.AND.Hmax3/=Hmax2)diagfile=.false.
          if(.not.diagfile) close(4697)
        endif

        if(.not.diagfile)then
        allocate(eigvecH(Hmax2,Hmax2,mat_rnk)) ! This is initially the 2 particle Hamiltonian
        read(4692)eigvecH
        if(size(kernel2) >= Smax)read(4692)kernel2
        close(4692)
        endif
      else
C----------------------------------------------------------------------------------
C
C   H(:,:,ind) ind=1 when TDA and npm=1, ind=1,2 for either npm=2 OR TDA
C   off, ind=1,2,3,4 when npm=2 AND TDA off
C
C----------------------------------------------------------------------------------
      allocate(eigvecH(Hmax2,Hmax2,mat_rnk))
      call dpzero(eigvecH,2*size(eigvecH))
C      eigvecH=0.0d0
      open(UNIT=3111,file='freq_r')
      read(3111,*) nwp, nw_i
      CLOSE(3111)

      call BSE_kernel(qbas,ginv,mrecl,nl,nband,nlmto,nclass,natom,
     .              iclass,nspin,nqbz,nqibz,qbz,qibz(1:3,1:nqibz),wbz,
     .              ngrp,symgg,irk,miat,tiat,invg,shtvg,qsub,
     .              nblochpmx,cond_default_stsp,Hmax2,nxx,
     .              valn_default_stsp,num_cond_statessp,num_valnsp,
     .              Smax,nnc,nn,il,in,im,nlnm,nlnmx,nlnmc,nlnmv,ncore,
     .              nctot,icore,min_diagval,opt_abs,eigvecH,kernel2,
     .              szk2,Hermit_H,npm,q_index,switchr,EELS_calc,nq0i,
     .              Chi_RIXS,mat_rnk,conv_bnds,nwp,Chi_dir,alat)

         new_kern = .true.
         IF(rst_from_krn)then
         open(4692,FILE='kern_out',form=
     .          'unformatted')
         rewind 4692
         write(4692)qsub
         write(4692)num_valnsp(1)
         write(4692)shape(eigvecH(:,:,1))
         write(4692)eigvecH
         if(size(kernel2) >= Smax)write(4692)kernel2
         close(4692)
         endif
      endif

      if(diagfile)goto 607
C Kernel multiplied by 2 to convert from Hartree to Rydberg?

      do lambindp = 1, Hmax2
          do lambind = 1, lambindp

             if(lambind <= Hmax)then
             eigvecH(lambind,lambindp,1) = -1.0d0*occdiff(lambind)*(
     .                      2.0d0/(numkpts)) *
     .                        eigvecH(lambind,lambindp,1)
C             if(lambind /= lambindp)eigvecH(lambindp,lambind)=
C     .          dconjg(eigvecH(lambind,lambindp))
      if(npm==2)eigvecH(lambind,lambindp,2)=-1.0d0*occdiff(lambind+Hmax)
     .  *2.0d0/numkpts*eigvecH(lambind,lambindp,2)
             else
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
             endif
             if(lambind==lambindp)then
                if(lambind <= Hmax)then
                eigvecH(lambind,lambind,1)=Hdiag(lambind) +
     .                eigvecH(lambind,lambind,1)
        if(npm==2)eigvecH(lambind,lambind,2)=Hdiag(lambind+Hmax)+
     .                eigvecH(lambind,lambind,2)
                else
C                H2p(lambind,lambind)=-Hdiag(lambind-Hmax) +
C     .                 H2p(lambind,lambind)
                endif
             end if
          end do
        enddo
      deallocate(kernel2)
C-----------------------------------------------
      if(.not.new_kern.and.rst_from_diag)
     .       INQUIRE(FILE='diag_out',EXIST=diagfile)

      if(diagfile)then
       open(4697,FILE='diag_out',form='unformatted')
          rewind 4697
          read(4697)qsub_kern
          if(abs(qsub_kern(1)-qsub(1))>1E-7.or.
     .  abs(qsub_kern(2)-qsub(2))>1E-7.or.
     .  abs(qsub_kern(3)-qsub(3))>1E-7)diagfile=.false.
          read(4697)Hmax3
          if(Hermit_H.and.Hmax3/=Hmax)diagfile=.false.
          IF(.NOT.HERMIT_H.AND.Hmax3/=Hmax2)diagfile=.false.
          if(.not.diagfile) close(4697)
      endif

 607  continue
      write(*,*)'start of diagonalization'
      allocate(eigvalH(Hmax2,mat_rnk))
      eigvalH=0.0d0
      if(diagfile)then
      write(*,*)'reading in'
         allocate(eigvecH(Hmax2,Hmax2,mat_rnk))
         read(4697)eigvalH
         read(4697)eigvecH
         write(*,*)eigvalH
         close(4697)
      deallocate(kernel2)
      else
      write(*,*)'Diagonalised H read in from previous run? =', diagfile

      if (.not. hermit_h) call rx('Non Hermitian mode not supported yet. Exiting..')
      IF(conv_bnds)then
        write(*,*)'ignoring diagonalization for conv test'
      ELSE

      DO ind1=1,npm
         IF(HERMIT_H)THEN
            if(nspin==1)then
            IF(Hmax2 <= memtol)THEN
           call diagc_bcHD(eigvecH(:,:,ind1),Hmax2,eigvalH(:,ind1),ind1)
            else
           call diagc_bcH(eigvecH(:,:,ind1),Hmax2,eigvalH(:,ind1))
            endif
            ELSE
            IF(Hmax2 <= memtol*2)THEN
              if(opt_abs)then
                call diagc_bcHD(eigvecH,Hmax2,eigvalH,ind1)
               if(npm==2)call rx('TRS off not ready yet for absorption')
              else
        write(*,*)'ind=',ind1,Smax_sp(1),Smax_sp(2)
          IF(q_index>nqibz.and.Chi_dir)THEN
        if(Hmax2 <= memtol)call diagc_bcHD(eigvecH(:,:,ind1),Hmax2,
     .          eigvalH(:,ind1),ind1)
        if(Hmax2>memtol)call diagc_bcH(eigvecH(:,:,ind1),Hmax2,
     .          eigvalH(:,ind1),ind1)
          ELSE
          call diagc_bcHD(eigvecH(1:Smax_sp(1),1:Smax_sp(1),ind1),
     .                      Smax_sp(1),eigvalH(1:Smax_sp(1),ind1),ind1)
        write(*,*)Smax_sp(1),Smax_sp(2)
          call diagc_bcHD(eigvecH(Smax_sp(1)+1:Hmax2,Smax_sp(1)+1:Hmax2,
     .          ind1),Smax_sp(2),eigvalH(Smax_sp(1)+1:Hmax2,ind1),ind1)
          ENDIF
C         call diagc_bcHD(eigvecH,Hmax2,eigvalH)
              endif
            ELSE
              if(opt_abs)then
              call diagc_bcH(eigvecH,Smax,eigvalH)
                if(npm==2)call rx('TRS off not ready for absorp yet')
              else
          IF(q_index>nqibz.and.Chi_dir)THEN
          call diagc_bcH(eigvecH(:,:,ind1),Hmax2,eigvalH(:,ind1),ind1)
          ELSE
          call diagc_bcH(eigvecH(1:Smax_sp(1),1:Smax_sp(1),ind1),
     .                          Smax_sp(1),eigvalH(1:Smax_sp(1),ind1))
      call diagc_bcH(eigvecH(Smax_sp(1)+1:Hmax2,Smax_sp(1)+1:Hmax2,ind1)
     .                     ,Smax_sp(2),eigvalH(Smax_sp(1)+1:Hmax2,ind1))
C              call diagc_bcH(eigvecH(:,:,ind1),Smax,eigvalH(:,ind1))
          ENDIF
              endif
            endif
            ENDIF
          ELSE
C             call diagc_bc(eigvecH,Hmax2,eigvalH)! Do we need left eigenvectors?
          ENDIF
      ENDDO ! Loop over Postive and negative frequencies
      ENDIF
C--------------------------------------------------------------------
C
C
C
C-------------------------------------------------------------------

         write(*,*)'matrix diagonalized'
         IF(rst_from_diag)then
         open(4697,FILE='diag_out',form=
     .          'unformatted')
         rewind 4697
         write(4697)qsub
         write(4697)shape(eigvalH(:,1))
         write(4697)eigvalH
         write(4697)eigvecH
         write(4697)num_valnsp(1),num_cond_statessp(1)
         if(nspin==2)write(4697)num_valnsp(2),num_cond_statessp(2)
         close(4697)
         endif
C      endif

      end if
C        if(.not.diagfile)deallocate(H2p)
      ENDIF
      if(.NOT.Hermit_H)then

      allocate(overlapH_inv(Hmax2,Hmax2))

      call zgemm('C','N',Hmax2,Hmax2,Hmax2,dcmplx(1d0,0d0),eigvecH,
     .          Hmax2,eigvecH,Hmax2,dcmplx(0d0,0d0),overlapH_inv,Hmax2)
      write(*,*)'inverting the overlap matrix'
C------------------------------------------------------
       call matcinv(Hmax2,overlapH_inv)
C------------------------------------------------------

      end if

      IF(Chi_RIXS)THEN
      call getkeyvalue("GWinput","MaxOmega_RIXS",max_omega,
     & default=1d0)     ! In Rydbergs?
      call getkeyvalue("GWinput","MinOmega_RIXS",min_omega,
     & default=0.0d0)
      call getkeyvalue("GWinput","numOmega_RIXS",numOmega,
     & default=101)

C        CALL Chi_RIXS_SUB(Hmax2,eigvecH,eigvalH,occdiff,nspin,numkpts,
C     .   num_valnsp,num_cond_statessp,valn_default_stsp,
C     .   valn_default_endsp,cond_default_stsp,cond_default_end,q_index,
C     .   max_omega,min_omega,numOmega)
        GOTO 169
      ENDIF
      IF(opt_abs)goto 142
C converting back to E_mu basis
       ary=1
       if(npm==2)ary=2
       open(2892,file='XVcousq',form='unformatted')
        rewind 2892
        read(2892)ngb
        if(q_index==1)read(2892)Vc1
        allocate(zzmeltppovlz(Hmax*ary,ngb))  ! May be 2*Hmax!
        allocate(Vcoud(ngb),Vcousq(ngb))
        read(2892)Vcoud
        read(2892)zzmeltppovlz
         CLOSE(2892)
        DO mu_ind = 1, ngb
           Vcousq(mu_ind) = 1d0/sqrt(Vcoud(mu_ind))
        ENDDO

      allocate(Pbar(Hmax*ary,ngb))

      call zgemm('C','N',Hmax,ngb,Hmax,dcmplx(1d0,0d0),eigvecH(:,:,1),
     .  Hmax,zzmeltppovlz(1:Hmax,1:ngb),Hmax,dcmplx(0d0,0d0),
     .  Pbar(1:Hmax,:),Hmax)

      if(npm==2)then
      call zgemm('C','N',Hmax,ngb,Hmax,dcmplx(1d0,0d0),eigvecH(:,:,2),
     .  Hmax,zzmeltppovlz(Hmax+1:2*Hmax,1:ngb),Hmax,dcmplx(0d0,0d0),
     .  Pbar(Hmax+1:2*Hmax,:),Hmax)
      endif

C ------- Loop over real axis first -----------

      open(UNIT=3111,file='freq_r')
      rewind(3111)
      read(3111,*) nwp, nw_i
C      if(nw_i /= 0)call rx('BSE written for T.R.S. on, nw_i from freq_r
C     .  is not zero')
      allocate(omega(nw_i:nwp-1))
        do ind1= nw_i, nwp-1
          read(3111,*) omega(ind1),ind2
        enddo
      CLOSE(3111)
        if (nw_i/=0) then
          if (nwp-1/= -nw_i)       call rx("sxcf_fal3_scz: nw/=-nwr0")
          if (omega(0)/=0d0)    call rx("sxcf_fal3_scz: freqr(0)/=0")
          if (sum(abs(omega(1:nwp-1)+omega(-1:-(nwp-1):-1)))/=0)
     .                  call rx("sxcf_fal3_scz: freqr /= -freqr")
        endif

      call getkeyvalue("GWinput","omg_c",omg_c)

      nw_max = nwp-1 ! CHECK!
      nw_min =  nw_i

      Max_omega = omega(nwp-1)
      Min_omega = omega(nw_i)
C----------------------------------------------------------------------

      allocate(Pright(Hmax*ary,ngb),eps_new(ngb,ngb),
     .     PrightRPA(Hmax*ary,ngb))

      allocate(zw(nblochpmx,nblochpmx))
      if(q_index <= nqibz)then
        ifrcw = iopen('WVR.'//charnum5(q_index),0,-1,mrecl)
        if(x0_small)then
          ifrcw2 = iopen('WV_small/WVR.'//charnum5(q_index),0,-1,mrecl)
          allocate(zw2(nblochpmx,nblochpmx))
          allocate(eps_inv2(ngb,ngb))
        endif
        ifrcwB = iopen('WVRBSE.'//charnum5(q_index),0,-1,mrecl)
      elseif(q_index>nqibz)then
        ifepsfile=iopen('epsR.'//charnum5(q_index),0,-1,mrecl)
        if(x0_small) ifepsfilesmall=iopen('WV_small/epsR.'//charnum5(q_index),0,-1,mrecl)
        if (allocated(eps_inv2)) deallocate(eps_inv2)
        allocate(eps_inv2(ngb,ngb))
        allocate(epstilde(ngb,ngb))
      endif

      allocate(eps_inv(ngb,ngb))

      if(q_index==nqibz+1) allocate(llw(nw_min:nw_max,nq0i),llwI(niw,nq0i))
      if(q_index==nqibz+1) allocate(freq_r(0:nwp-1))
      if(q_index==nqibz+1) freq_r(0:nwp-1)=omega(0:nwp-1)
      fac=dcmplx(1.0d0,0.0d0)
      if(x0_small) fac=dcmplx(0.0d0,0.0d0)

      write(*,*)'eps(2,2) BSE,RPA,lx0 (Many transitions)'

      do wind = nw_min, nw_max

        ImagEs=0.5d0*(imagE2-ImagE1)/(Max_omega-min_omega)*omega(wind)+
     .   0.5d0*(ImagE1*max_omega-min_omega*ImagE2)/(max_omega-min_omega)

C        IF(npm == 1.and.omega(wind)<min_diagval)
C    .                ImagEs=ImagE1/min_diagval*omega(wind)+0.0001d0!increases linearly from 0 to imagE1 at min_diagval

        do lambind = 1, Hmax*ary
           do mu_ind=1, ngb

             if (npm==1) then
               if (Gauss_BSE .or. abs(omega(wind)) < Gauss_CO) then
                 PrightRPA(lambind,mu_ind)=zzmeltppovlz(lambind,mu_ind)*(
     .           (1.0d0*omega(wind)-0.5d0*Hdiag(lambind))/
     .          ((1.0d0*omega(wind)-0.5d0*Hdiag(lambind))**2+imagEs**2)-
     .           (1.0d0*omega(wind)+0.5d0*Hdiag(lambind))/
     .          ((1.0d0*omega(wind)+0.5d0*Hdiag(lambind))**2+imagEs**2)-
     .           zimag/imagEs*
     .         (exp(-(1.0d0*omega(wind)-0.5d0*Hdiag(lambind))**2/(2*imagEs**2))
     .         +exp(-(1.0d0*omega(wind)+0.5d0*Hdiag(lambind))**2/(2*imagEs**2))
     .           ))
C         if(real(eigvalH(lambind,1))<0)imagEs = -imagEs

                 Pright(lambind,mu_ind)=Pbar(lambind,mu_ind)*(
     .  (1.0d0*omega(wind)-0.5d0*eigvalH(lambind,1))/
     . ((1.0d0*omega(wind)-0.5d0*eigvalH(lambind,1))**2+imagEs**2)-
     .  (1.0d0*omega(wind)+0.5d0*eigvalH(lambind,1))/
     . ((1.0d0*omega(wind)+0.5d0*eigvalH(lambind,1))**2+imagEs**2)-
     .  zimag/imagEs*
     .(exp(-(1.0d0*omega(wind)-0.5d0*eigvalH(lambind,1))**2/
     .(2*imagEs**2))
     .+exp(-(1.0d0*omega(wind)+0.5d0*eigvalH(lambind,1))**2/(2*imagEs**2
     . )) ))
      else
      PrightRPA(lambind,mu_ind)=zzmeltppovlz(lambind,mu_ind)*(
     .          1d0/(omega(wind)-0.5d0*Hdiag(lambind)+zimag*imagEs)-
     .          1d0/(omega(wind)+0.5d0*Hdiag(lambind)-zimag*imagEs))  ! No occupations here, also are the zimag*imagE the wrong way about? ± -> -+?

             Pright(lambind,mu_ind)=Pbar(lambind,mu_ind)*(
     .    1d0/(1.0d0*omega(wind)-0.5d0*eigvalh(lambind,1)+zimag*images)-
     .    1d0/(1.0d0*omega(wind)+0.5d0*eigvalh(lambind,1)-zimag*images))! no occupations here, also are the zimag*image the wrong way about? ± -> -+?
      endif
      ELSE ! npm=2
      if(lambind <= Hmax)inds=1
      if(lambind>Hmax)inds=2

      if(Gauss_BSE.or.abs(omega(wind))<Gauss_CO)then

      PrightRPA(lambind,mu_ind)=-zzmeltppovlz(lambind,mu_ind)*
     .          occdiff(lambind)*(
     .  (1.0d0*omega(wind)-0.5d0*Hdiag(lambind))/
     . ((1.0d0*omega(wind)-0.5d0*Hdiag(lambind))**2
     .  +imagEs**2)+occdiff(lambind)*zimag/imagEs*
     .(exp(-(1.0d0*omega(wind)-0.5d0*Hdiag(lambind))**2/(2*imagEs**2))
     .  ))

CC        if(real(eigvalH(lambind,1))<0)imagEs = -imagEs

             Pright(lambind,mu_ind)=-Pbar(lambind,mu_ind)*
     .  occdiff(lambind)*(
     .  (1.0d0*omega(wind)-0.5d0*EigvalH(lambind-(inds-1)*Hmax,inds))/
     . ((1.0d0*omega(wind)-0.5d0*EigvalH(lambind-(inds-1)*Hmax,inds))**2
     .  +imagEs**2)+occdiff(lambind)*zimag/imagEs*
     .(exp(-(1.0d0*omega(wind)-0.5d0*EigvalH(lambind-(inds-1)*Hmax,inds)
     .  )**2/(2*imagEs**2))))

      else
      PrightRPA(lambind,mu_ind)=-zzmeltppovlz(lambind,mu_ind)*
     .          occdiff(lambind)*(
     .          1d0/(omega(wind)-0.5d0*Hdiag(lambind)-
     .                  occdiff(lambind)*zimag*imagEs))!-
             Pright(lambind,mu_ind)=-Pbar(lambind,mu_ind)*
     .  occdiff(lambind)*(
     . 1d0/(1.0d0*omega(wind)-0.5d0*eigvalh(lambind-(inds-1)*Hmax,inds)
     .  -occdiff(lambind)*zimag*images))!-
      endif
      ENDIF
           ENDDO
        ENDDO

        call zgemm('C','N',ngb,ngb,Hmax*ary,dcmplx(1d0,0d0),zzmeltppovlz
     .  ,Hmax*ary,PrightRPA,Hmax*ary,dcmplx(0d0,0d0),eps_new,ngb) ! We now have the change in the dielectric function due to excitonic effects from the states considered. This is now added to eps_RPA.
        tocomp=1.0d0-2.0d0/nspin*eps_new(2,2)/numkpts

        call zgemm('C','N',ngb,ngb,Hmax*ary,dcmplx(-1d0,0d0),Pbar,
     .          Hmax*ary,Pright,Hmax*ary,fac,eps_new,ngb)
        if(x0_small)then

        tocomp2 = 1.0d0+2.0d0/nspin*eps_new(2,2)/numkpts
        else
        tocomp2 = eps_new(2,2)/nspin/numkpts*2.0d0+tocomp
        endif
C        endif
C---------------------------------------------
        if(nspin==1)eps_new = eps_new*2.0d0
        eps_new = eps_new/numkpts
        if(q_index==1)then
        eps_new(1,:)=0d0
        eps_new(:,1)=0d0
        endif

         iw = wind-nw_min+1
        if(q_index <= nqibz)then

          read(ifrcw,rec=iw)zw
          eps_inv = 0d0
          ix=0
          if(q_index==1)ix=1
          DO mu_ind = 1+ix, ngb
            DO nu_ind = 1+ix, ngb
              eps_inv(nu_ind,mu_ind) = zw(nu_ind,mu_ind)*Vcousq(mu_ind)*
     .                                 Vcousq(nu_ind)
           IF(mu_ind==nu_ind)eps_inv(nu_ind,mu_ind) =
     .          eps_inv(nu_ind,mu_ind)+1.0d0
           ENDDO
          ENDDO

         call matcinv(ngb-ix,eps_inv(1+ix:ngb,1+ix:ngb)) ! Now we have eps
      IF(x0_small)then
         read(ifrcw2,rec=iw)zw2

         eps_inv2 = 0d0
         forall (mu_ind = 1:ngb) eps_new(mu_ind,mu_ind) = eps_new(mu_ind,mu_ind) + 1.0d0
         do mu_ind = 1+ix, ngb
           do nu_ind = 1+ix, ngb
              eps_inv2(nu_ind,mu_ind) = zw2(nu_ind,mu_ind) * vcousq(mu_ind) * vcousq(nu_ind)
              if(mu_ind==nu_ind)eps_inv2(nu_ind,mu_ind) = eps_inv2(nu_ind,mu_ind)+1.0d0
           enddo
         enddo

         call matcinv(ngb-ix,eps_inv2(1+ix:ngb,1+ix:ngb)) ! Now we have eps
        write(*,FMT='(7F15.10)')omega(wind),real(tocomp2),imag(tocomp2),
     .          real(tocomp),imag(tocomp),
     .          real(eps_inv2(2,2)),imag(eps_inv2(2,2))
       eps_new = eps_inv - eps_inv2 + eps_new
      ELSE
       write(*,FMT='(7F15.10)')omega(wind),real(tocomp2),imag(tocomp2),
     .          real(tocomp),imag(tocomp),
     .          real(eps_inv(2,2)),imag(eps_inv(2,2))
        eps_new = eps_inv + eps_new!/numkpts/cell_vol ! 1/N^2 prefactor in the inverse??????
      ENDIF

        if(conv_bnds)cycle

        call matcinv(ngb-ix,eps_new(1+ix:ngb,1+ix:ngb)) ! Invert to get inverse of new eps
        DO mu_ind = 1+ix, ngb
          DO nu_ind=1+ix, ngb
C          if(imag(eps_new(nu_ind,mu_ind))<0.0d0)
C     .  eps_new(nu_ind,mu_ind)=real(eps_new(nu_ind,mu_ind))+zimag*0.0d0
            zw(nu_ind,mu_ind)=eps_new(nu_ind,mu_ind)*
     .          sqrt(Vcoud(mu_ind))*sqrt(Vcoud(nu_ind))
          IF(mu_ind==nu_ind)
     .       zw(mu_ind,nu_ind)=zw(mu_ind,nu_ind)-Vcoud(mu_ind)
          ENDDO
        ENDDO

      write(ifrcwB,rec=iw)zw

      else ! q_index >  nqibz
        vc1 = fpi/sum(qsub**2*(2d0*pi/alat)**2) ! --> vcousq(1)**2 = fourpi/sum(q**2*tpioa**2-eee)
        read(ifepsfile,rec=iw)eps_inv
C######################################################
        if(x0_small.and..not.Chi_dir)then
        read(ifepsfilesmall,rec=iw)eps_inv2
        do ind1=1,ngb
          do ind2=1,ngb
            if(ind1==1.and.ind2==1)then
            epstilde(ind2,ind1)=-((eps_inv2(ind2,ind1)-eps_inv(ind2,ind1))/Vc1
     .       -(eps_new(ind2,ind1))/(sqrt(Vcoud(ind2))*sqrt(Vcoud(ind1))))*
     .       Vcoud(ind1)
            else
            epstilde(ind2,ind1)=-(eps_inv2(ind2,ind1)-eps_inv(ind2,ind1)
     .       -eps_new(ind2,ind1))/(sqrt(Vcoud(ind2))*sqrt(Vcoud(ind1)))*
     .       Vcoud(ind1)
            endif
          if(ind1==1)epstilde(ind2,ind1)=0.0d0
          if(ind1==ind2)epstilde(ind2,ind1)=1.0d0+epstilde(ind2,ind1)
          enddo
        enddo
        call matcinv(ngb,epstilde)
        Pmod=0.0d0
        do ind1=1,ngb
             if(ind1==1)then
        Pmod=Pmod+epstilde(1,ind1)*((eps_inv2(ind1,1)-eps_inv(ind1,1))/
     .        Vc1-eps_new(ind1,1)/(sqrt(Vcoud(1))*sqrt(Vcoud(ind1))))
            else
         Pmod=Pmod+epstilde(1,ind1)*(eps_inv2(ind1,1)-eps_inv(ind1,1)
     .       -eps_new(ind1,1))/(sqrt(Vcoud(1))*sqrt(Vcoud(ind1)))
            endif
        enddo
        iq0=q_index-nqibz
        llw(wind,iq0)=1.0d0-Vc1*Pmod
      goto 265
      endif
C######################################################
      if(x0_small)then
        read(ifepsfilesmall,rec=iw)eps_inv2
C        write(*,FMT='(7F15.10)')omega(wind),real(tocomp2),imag(tocomp2),
C     .          real(tocomp),imag(tocomp),
C     .          real(eps_inv2(2,2)),imag(eps_inv2(2,2))
        else
        write(*,FMT='(7F15.10)')omega(wind),real(tocomp2),imag(tocomp2),
     .          real(tocomp),imag(tocomp),
     .          real(eps_inv(2,2)),imag(eps_inv(2,2))
        endif
        if(Chi_dir)then
          eps_new(1,1)=1.0d0+Vc1*eps_new(1,1)/Vcoud(1)
          call matcinv(ngb,eps_inv); call matcinv(ngb,eps_inv2)
          iq0=q_index-nqibz
          llw(wind,iq0)=1.0d0/(eps_inv(1,1)-eps_inv2(1,1)+
     .          1.0d0/eps_new(1,1))
          write(*,*)llw(wind,iq0)
        else
        do ind1=1,ngb
          do ind2=1,ngb
             if(ind1==1.and.ind2==1)then
                eps_new(ind1,ind2)=vc1*(eps_new(1,1))/Vcoud(1)! Vcoud was multiplied above (in kernel)
C                cycle
             endif
C             if (ind1==ind2) then
              if(x0_small)then
               eps_new(ind1,ind2) = eps_new(ind1,ind2)+
     .         eps_inv(ind1,ind2)-eps_inv2(ind1,ind2)
              if(ind1==ind2)eps_new(ind1,ind1)=1.0d0+eps_new(ind1,ind1)
              else
               eps_new(ind1,ind2) = eps_new(ind1,ind2)+
     .         eps_inv(ind1,ind2)!-eps_inv2(ind1,ind2)
              endif
C          if(imag(eps_new(nu_ind,mu_ind))<0.0d0)
C     . eps_new(nu_ind,mu_ind)=real(eps_new(nu_ind,mu_ind))+0.0d0*zimag
C             endif

          enddo
        enddo
        call matcinv(ngb,eps_new(1:ngb,1:ngb))
        iq0=q_index-nqibz
        llw(wind,iq0)= 1d0/eps_new(1,1)
        endif
 265  continue
      endif
      ENDDO
      CLOSE(3124);CLOSE(3125)
      if(q_index <= nqibz)then
      ifrcw = iclose('WVR.'//charnum5(q_index))
      if(x0_small)ifrcw2 = iclose('WV_small/WVR.'//charnum5(q_index))
      ifrcwB = iclose('WVRBSE.'//charnum5(q_index))
      else
        ifepsfile=iclose('epsR.'//charnum5(q_index))
       if(x0_small)
     .ifepsfilesmall=iclose('WV_small/epsR.'//charnum5(q_index))
      endif
        write(*,*)'Real frequiencies'
      deallocate(omega)

      allocate(omega(niw),freqx(niw),wx(niw),expa(niw) )
      call freq01 (niw,ua,freqx,omega,wx,expa)
      deallocate(freqx,wx,expa)

      if(q_index <= nqibz)then
      ifrcwi = iopen('WVI.'//charnum5(q_index),0,-1,mrecl)
      if(x0_small)
     .  ifrcwi2 = iopen('WV_small/WVI.'//charnum5(q_index),0,-1,mrecl)
      ifrcwiB = iopen('WVIBSE.'//charnum5(q_index),0,-1,mrecl)
      else
        ifepsfileI=iopen('epsI.'//charnum5(q_index),0,-1,mrecl)
       if(x0_small)ifepsfileIsmall=
     .  iopen('WV_small/epsI.'//charnum5(q_index),0,-1,mrecl)
      endif
      if(q_index==nqibz+1)allocate(freq_i(niw))
      if(q_index==nqibz+1)freq_i=omega
      Do wind = 1, niw
         ImagE = imagE2 ! Change??????????????

        ImagEs=0.5d0*(imagE2-ImagE1)/(Max_omega-min_omega)*omega(wind)+
     .   0.5d0*(ImagE1*max_omega-min_omega*ImagE2)/(max_omega-min_omega)
        ImagEs=(1E-7)*ImagEs

        DO lambind=1, Hmax*ary
C          IF(real(eigvalH(lambind,1))<0)imagEs = -imagE
           DO mu_ind = 1, ngb
          IF(npm==1)THEN
            PrightRPA(lambind,mu_ind)=zzmeltppovlz(lambind,mu_ind)*(
     .        1d0/(zimag*omega(wind)-0.5d0*Hdiag(lambind)+zimag*imagEs)-
     .        1d0/(zimag*omega(wind)+0.5d0*Hdiag(lambind)-zimag*imagEs))! No occupations here, also are the zimag*imagE the wrong way about? ± -> -+?

             Pright(lambind,mu_ind)=Pbar(lambind,mu_ind)*(
     .    1d0/(zimag*omega(wind)-0.5d0*eigvalH(lambind,1)+zimag*imagEs)-
     .    1d0/(zimag*omega(wind)+0.5d0*eigvalH(lambind,1)-zimag*imagEs))! No occupations here, also are the zimag*imagE the wrong way about? ± -> -+?

          ELSE
            PrightRPA(lambind,mu_ind)=-zzmeltppovlz(lambind,mu_ind)*(
     .       occdiff(lambind)*1d0/
     .          (zimag*omega(wind)-0.5d0*Hdiag(lambind)-occdiff(lambind)
     .          *zimag*imagEs))

       if(lambind <= Hmax)inds=1
       if(lambind>Hmax)inds=2
        Pright(lambind,mu_ind)=-Pbar(lambind,mu_ind)*(occdiff(lambind)*
     .  1d0/(zimag*omega(wind)-0.5d0*eigvalH(lambind-(inds-1)*Hmax,inds)
     .          -occdiff(lambind)*zimag*imagEs))
         ENDIF
            END DO
        ENDDO

        call zgemm('C','N',ngb,ngb,Hmax*ary,dcmplx(1d0,0d0),zzmeltppovlz
     .  ,Hmax*ary,PrightRPA,Hmax*ary,dcmplx(0d0,0d0),eps_new,ngb) ! We now have the change in the dielectric function due to excitonic effects from the states considered. This is now added to eps_RPA.

        call zgemm('C','N',ngb,ngb,Hmax*ary,dcmplx(-1d0,0d0),Pbar,
     .          Hmax*ary,Pright,Hmax*ary,fac,eps_new,ngb)

        if(nspin==1)eps_new = eps_new*2.0d0
        eps_new =  eps_new/numkpts

        if(q_index==1)then
        eps_new(1,:)=0d0
        eps_new(:,1)=0d0
        endif
         iw = wind

        if(q_index <= nqibz)then

          read(ifrcwi,rec=iw)zw

C          eps_inv=0d0
C          eps_inv2=0d0
         ix=0
          if(q_index==1)ix=1
          DO mu_ind = 1+ix, ngb
            DO nu_ind = 1+ix, ngb
              eps_inv(nu_ind,mu_ind) = zw(nu_ind,mu_ind)*Vcousq(mu_ind)*
     .                                 Vcousq(nu_ind)
            IF(mu_ind==nu_ind)eps_inv(nu_ind,mu_ind) =
     .          eps_inv(nu_ind,mu_ind)+1.0d0
            ENDDO
          ENDDO
          call matcinv(ngb-ix,eps_inv(1+ix:ngb,1+ix:ngb)) ! Now we have eps
        IF(x0_small)then
           do mu_ind=1, ngb; eps_new(mu_ind,mu_ind)=
     .  eps_new(mu_ind,mu_ind)+1.0d0; enddo
        read(ifrcwi2,rec=iw)zw2
         DO mu_ind = 1+ix, ngb
            DO nu_ind = 1+ix, ngb
              eps_inv2(nu_ind,mu_ind)=zw2(nu_ind,mu_ind)*Vcousq(mu_ind)*
     .                                 Vcousq(nu_ind)
            IF(mu_ind==nu_ind)eps_inv2(nu_ind,mu_ind) =
     .          eps_inv2(nu_ind,mu_ind)+1.0d0
            ENDDO
          ENDDO
         call matcinv(ngb-ix,eps_inv2(1+ix:ngb,1+ix:ngb)) ! Now we have eps
         eps_new=eps_new+eps_inv-eps_inv2
          ELSE
          eps_new = eps_inv + eps_new
          ENDIF

        call matcinv(ngb-ix,eps_new(1+ix:ngb,1+ix:ngb)) ! Invert to get inverse of new eps

        DO mu_ind = 1+ix, ngb
          DO nu_ind=1+ix, ngb
            zw(nu_ind,mu_ind)=eps_new(nu_ind,mu_ind)*
     .          sqrt(Vcoud(mu_ind))*sqrt(Vcoud(nu_ind))
          IF(mu_ind==nu_ind)
     .       zw(mu_ind,nu_ind)=zw(mu_ind,nu_ind)-Vcoud(mu_ind)
          ENDDO
        ENDDO

        write(ifrcwiB,rec=iw)zw
      else
       vc1 = fpi/sum(qsub**2*(2d0*pi/alat)**2) ! --> vcousq(1)**2 = fourpi/sum(q**2*tpioa**2-eee)
        read(ifepsfileI,rec=iw)eps_inv
C######################################################
        if(x0_small.and..not.Chi_dir)then
        read(ifepsfilesmall,rec=iw)eps_inv2
        do ind1=1,ngb
          do ind2=1,ngb
             if(ind1==1.and.ind2==1)then
            epstilde(ind2,ind1)=-((eps_inv2(ind2,ind1)-eps_inv(ind2,ind1))/Vc1
     .       -(eps_new(ind2,ind1))/(sqrt(Vcoud(ind2))*sqrt(Vcoud(ind1))))*
     .       Vcoud(ind1)
            else
           epstilde(ind2,ind1)=-(eps_inv2(ind2,ind1)-eps_inv(ind2,ind1)
     .       -eps_new(ind2,ind1))/(sqrt(Vcoud(ind2))*sqrt(Vcoud(ind1)))*
     .       Vcoud(ind1)
            endif
          if(ind1==1)epstilde(ind2,ind1)=0.0d0
          if(ind1==ind2)epstilde(ind2,ind1)=1.0d0+epstilde(ind2,ind1)
          enddo
        enddo
        call matcinv(ngb,epstilde)
        Pmod=0.0d0
        do ind1=1,ngb
              if(ind1==1)then
        Pmod=Pmod+epstilde(1,ind1)*((eps_inv2(ind1,1)-eps_inv(ind1,1))/Vc1
     .       -eps_new(ind1,1)/(sqrt(Vcoud(1))*sqrt(Vcoud(ind1))))
            else
         Pmod=Pmod+epstilde(1,ind1)*(eps_inv2(ind1,1)-eps_inv(ind1,1)
     .       -eps_new(ind1,1))/(sqrt(Vcoud(1))*sqrt(Vcoud(ind1)))
            endif
        enddo
        iq0=q_index-nqibz
        llwi(iw,iq0)=1.0d0-Vc1*Pmod
      endif
      if(x0_small.and..not.Chi_dir)goto 263
C######################################################

        if(x0_small)read(ifepsfileIsmall,rec=iw)eps_inv2
         if(Chi_dir)then
          eps_new(1,1)=1.0d0+Vc1*eps_new(1,1)/Vcoud(1)
          call matcinv(ngb,eps_inv); call matcinv(ngb,eps_inv2)
          iq0=q_index-nqibz
          llwi(iw,iq0)=1.0d0/(eps_inv(1,1)-eps_inv2(1,1)+
     .          1.0d0/eps_new(1,1))
        else
       do ind1=1,ngb
          do ind2=1,ngb
             if(ind1==1.and.ind2==1)then
                eps_new(ind1,ind2)=vc1*(eps_new(1,1))/Vcoud(1)! Vcoud was multiplied above (in kernel)
C                cycle
             endif
C             if (ind1==ind2) then
              if(x0_small)then
               eps_new(ind1,ind2) = eps_new(ind1,ind2)+
     .          eps_inv(ind1,ind2)-eps_inv2(ind1,ind2)
               if(ind1==ind2)eps_new(ind1,ind2)=1.0d0+eps_new(ind1,ind1)
              else
               eps_new(ind1,ind2) = eps_new(ind1,ind2)+
     .          eps_inv(ind1,ind2)!-eps_inv2(ind1,ind2)
              endif
C             endif
          enddo
        enddo
       call matcinv(ngb,eps_new(1:ngb,1:ngb))
        iq0=q_index-nqibz
        llwi(iw,iq0)= 1d0/eps_new(1,1)
      endif
 263  continue
      endif

      ENDDO
        CLOSE(3124);CLOSE(3125)
      if(q_index <= nqibz)then
      ifrcwi = iclose('WVI.'//charnum5(q_index))
      if(x0_small)ifrcwi2 = iclose('WV_small/WVI.'//charnum5(q_index))
      ifrcwiB = iclose('WVIBSE.'//charnum5(q_index))
      elseif(q_index>nqibz)then
        ifepsfileI=iclose('epsI.'//charnum5(q_index))
        if(x0_small)
     .  ifepsfileIsmall=iclose('WV_small/epsI.'//charnum5(q_index))
      endif
        write(*,*)'Imaginary frequencies'
        if(q_index==num_q)then

!!      Return w0 and w0i = diagonal element at Gamma point and llmat = L(omega=0) matrix.
!!      Outputs w0,w0i,llmat
        allocate(w0(nw_i:nw_max),w0i(niw))
        call w0w0i(0,.true.,llw,llwI,nw_min,nw_max,nq0i,niw,freq_r,freq_i,q0i,w0,w0i,llmat)

        do  ircw = 1, 2         ! Real and imaginary frequencies
          if (ircw==1) then
            ifrcwx = iopen('WVRBSE.'//charnum5(1),0,-1,mrecl)
          elseif (ircw==2) then
            nw_min=1; nw_max=niw
            ifrcwx = iopen('WVIBSE.'//charnum5(1),0,-1,mrecl)
          endif
          do iw=nw_min,nw_max
            read(ifrcwx, rec= iw-nw_min+1) zw !(1:ngb,1:ngb)
            if (ircw==1) zw(1,1) = w0(iw)
C           if (ircw==2)write(*,*)Real(w0i(iw))!Real(w0i(iw))+zimag*Imag(w0i(iw))*1E-10 ! Imaginary part for imaginary frequencies seems to calculated wrongly
            if (ircw==2) zw(1,1) =w0i(iw)
            write(ifrcwx,rec=iw-nw_min+1) zw !(1:ngb,1:ngb)
          enddo
          if (ircw==1) then
            ifrcwx = iclose('WVRBSE.'//charnum5(1))
          elseif (ircw==2) then
            ifrcwx = iclose('WVIBSE.'//charnum5(1))
          endif
        enddo                   ! Real, imaginary branches
        deallocate(freq_r)
        deallocate(freq_i)
        deallocate(w0)
        deallocate(w0i)
      endif                     ! last q-point

      deallocate(zzmeltppovlz,Pbar,eps_new,Pright,Vcoud,Vcousq,zw,omega,eps_inv,PrightRPA) !eps_inv2
      if(q_index == num_q)deallocate(llw,llwi)
      if(q_index <= nqibz.and.x0_small)deallocate(zw2,eps_inv2)
      if(q_index > nqibz)deallocate(epstilde)
C      deallocate(Pbarocc,
C     .  zzmeltppovlzocc)
 169  continue
      deallocate(Hdiag,eigvalH,eigvecH)

      if(allocated(OVLPbar))deallocate(OVLPbar)
        open(unit=7854,file='restart_q',form='formatted')
        rewind 7854
        write(7854,*)q_index+1
        write(7854,*)q_end
        close(7854)
      if(q_index==q_end)goto 135
      ENDDO ! end of q-loop
 142  continue
C-- frequency(energy) range over which absorption is calculated

      call getkeyvalue("GWinput","MaxOmega_BSE",max_omega,
     & default=1d0)     ! In Rydbergs?
      call getkeyvalue("GWinput","MinOmega_BSE",min_omega,
     & default=0.0d0)
      call getkeyvalue("GWinput","dOmega_BSE",deltaomg,
     & default=999d0)
      call getkeyvalue("GWinput","numOmega_BSE",numomega,
     & default=1001)

C if deltaomg given then can work out numomega from it. If it is not
C given then it is worked out from numomega

C Ensure these are consistent, i.e., dont change numomega and leave dw,
C as it will then determine numomega and overwrite the value you gave it

      if(deltaomg==999d0)then
         deltaomg = (max_omega - min_omega ) / (numomega-1)
      else
         numomega = 1 + (max_omega-min_omega)/deltaomg ! Will overwrite numomega from above
      end if
C----------------------------------------------------------------------
      allocate(omega(numomega))

      do wind = 1, numomega
         omega(wind) = min_omega + deltaomg * (wind-1)
      end do

      omega = omega * energy_scale
      write(*,*)'Frequencies defined'

C MPI_BCAST......
C------------------------------------
C

C     loop to work out optical matrix

      ifi=301
      open(ifi,file='optdatabse',form='UNFORMATTED')

      read(ifi)efermi_opt,ndham_opt,nsp_opt,nkp_opt
C do a check?
      write(*,*)'Ef,ndham,nsp,nk from optdatabse=',efermi_opt,ndham_opt,
     .           nsp_opt,nkp_opt
      if(nkp_opt/=nqibz) call rx('number of IBZ k points differ between
     & inputs')

      allocate(evals_opt(ndham_opt,nsp_opt,nkp_opt))
      read(ifi)evals_opt
      deallocate(evals_opt)

      allocate(qp_opt(3,nkp_opt))
!      read(ifi)nfilm,nempm,nspx,nkp_opt,qp_opt

      read(ifi) nfilo, nfiup, nemlo, nemup, nspx, nkp_opt, qp_opt
      write(*,*)'nfilo, nfiup, nemlo, nemup, nspx, nkp_opt, qp_opt'
      write(*,*) nfilo, nfiup, nemlo, nemup, nspx, nkp_opt, qp_opt

      nfilm = nfiup - nfilo + 1
      nempm = nemup - nemlo + 1

C      write(*,*)'nfilm,nempm=',nfilm,nempm

C      if(nfilm<sum(num_valnsp).or.nempm<sum(num_cond_statessp))
C     .call
C     & rx('number of valence (or conduction) states from lmf is LESS
C     & than that required for BSE! Change EMPBND or FILBND in
C     & ctrl file and run lmf --opt:write')

      do ind1=1,nkp_opt
           if(abs(qibz(1,ind1)-qp_opt(1,ind1)) >= 1E-7.or.
     .        abs(qibz(2,ind1)-qp_opt(2,ind1)) >= 1E-7.or.
     .        abs(qibz(3,ind1)-qp_opt(3,ind1)) >= 1E-7)
     .          call rx('q points differ with that from optdatabse')
      enddo
      deallocate(qp_opt)

      allocate(optmt(3,nfilo:nfiup,nemlo:nemup,nspx,nkp_opt))
      read(ifi)optmt
      deallocate(optmt)

      allocate(optmt2(3,nfilo:nfiup,nemlo:nemup,nspx,nkp_opt))

      read(ifi)optmt2
      close(ifi)
C      if(.not.QSGW_BSE.or.NL_fieldcorr.and.nempm>ntqTOTE-
C     .          sum(num_valnsp))nempm=ntqTOTE-sum(num_valnsp)

      if(nemup>nband)nemup=nband
      if(.not.QSGW_BSE.or.NL_fieldcorr)nemup=ntqtote
      Hmax_opt = numkpts*((num_val_sp(1)-nfilo+1)*(nemup-num_val_sp(1)))
      if(nspin==2)Hmax_opt=Hmax_opt +numkpts*
     .  (num_val_sp(2)-nfilo+1)*(nemup-num_val_sp(2))
      allocate(rho0(Hmax_opt))! Currently only written for sigma=sigma'
      rho0=0.0d0
      qvec=(/1d0,1d0,1d0/)
      call getkeyvalue("GWinput","Qvec_bse",qvec,3)
      qvecsize=sqrt(qvec(1)**2+qvec(2)**2+qvec(3)**2)
C      if(qvecsize<1E-8)then
C         qvec=(/1d0,1d0,1d0/)
C         qvecsize=sqrt(qvec(1)**2+qvec(2)**2+qvec(3)**2)
C      end if
      qvec = qvec/qvecsize

      if(NL_fieldcorr)WRITE(*,*)'LDA energies used as an approximation
     .  to account for a N.L. potential'
      if(NL_fieldcorr)WRITE(*,*)'NL_fieldcorr handled here, do not have',
     .  'OPTICS_MEFAC>0 in ctrl file, as this may multiply by the scaling factor twice'
      write(*,*)'Hmax_opt=',Hmax_opt
      allocate(HdiagIP(Hmax+1:Hmax_opt),
     .          occdiffIP(Hmax+1:Hmax_opt))

      do k_ind = 1, nqibz
        write(*,*)'k(optics)=',k_ind
        do is = 1, nspin
C        if(is /= 2)cycle
       IF(QSGW_BSE)call readeval(qibz(:,k_ind),is,evals)
C Spin-flip?
C        do is2 = 1, nspin
           is2 = is
           IF(QSGW_BSE)call readeval(qibz(:,k_ind),is2,evals2) ! optical absorption, q=0

         do ig = 1, ngrp
         if(irk(k_ind,ig)==0) cycle

         k_indfbz = irk(k_ind,ig)
               rho0t2(:) =matmul(symgg(:,:,invg(ig)),
     &                          qvec(:))

            do valind = valn_default_stsp(is), valn_default_endsp(is)
              do condind = cond_default_stsp(is), cond_default_endsp(is)

           sind=(is-1)*numkpts*num_valnsp(1)*num_cond_statessp(1)+
     .          (k_indfbz-1)*num_valnsp(is) *
     .          num_cond_statessp(is)+(valind-valn_default_stsp(is))*
     .          num_cond_statessp(is) + condind-cond_default_stsp(is)+1

C           sind=(is-1)*numkpts*num_valnsp(1)*num_cond_statessp(1)+
C     .          (k_indfbz-1)*num_valnsp(is) *
C     .          num_cond_statessp(is)+(valind-valn_default_stsp(is))*
C     .          num_cond_statessp(is) + condind-cond_default_stsp(is)+1
C Spin-flip?
C             sind = (k_indfbz-1)*nspin*num_valn*num_cond_states*nspin+
C     .         (is-1)*num_valn*nspin*num_cond_states+(is2-1)*num_valn*
C     .          num_cond_states+(valind-valn_default_st)*
C     .          num_cond_states + condind-cond_default_st+1
        rho0t=0

        do ind1=1, 3
        IF(NL_fieldcorr)THEN
            rho0t = rho0t + rho0t2(ind1)*
     &                   optmt2(ind1,valind,condind,is2,k_ind)/
     &                   (EDFT(k_ind,valind,is)-EDFT(k_ind,condind,is2))
C NOTE! Need to change the index to account for q\=0, however we can
C only read optmt2 for q=0.
        ELSE
           IF(QSGW_BSE)THEN
            rho0t = rho0t + rho0t2(ind1)*optmt2(ind1,valind,
     &        condind,is2,k_ind)/(evals2(valind)-evals(condind))

           ELSE
            rho0t = rho0t + rho0t2(ind1)*
     &                    optmt2(ind1,valind,condind,is2,k_ind)/
     &               (E_GWZ(k_ind,valind,is)-E_GWZ(k_ind,condind,is2))
           ENDIF
        ENDIF
        enddo

         rho0(sind) = zimag * rho0t     ! Goes up to Hmax

C      write(*,*)'s,rho=',sind,rho0(sind)
            end do
            end do

C---------------------------------------------------------------------
            do valind = nfilo, valn_default_stsp(is)-1
              do condind =cond_default_stsp(is), nemup

               sind =Hmax+(is-1)*numkpts*(valn_default_stsp(1)-nfilo)*
     .          (nemup-cond_default_stsp(1)+1)+
     .          (k_indfbz-1)*(valn_default_stsp(is)-nfilo) *
     .          (nemup-cond_default_stsp(is)+1)+(valind-nfilo)*
     .          (nemup-cond_default_stsp(is)+1)
     .           + condind-cond_default_stsp(is)+1

C Spin-flip?
C               sind = Hmax+(k_indfbz-1)*nspin*(valn_default_st-1)*nspin
C     .          nempm+(is-1)*(valn_default_st-1)*nempm*nspin+(is2-1)*
C     .          (valn_default_st-1)*nempm
C     .          +(valind-1)*nempm + condind-cond_default_st+1
        occdiffIP(sind) = occs(k_indfbz,is2,condind)-
     .          occs(k_indfbz,is,valind)

       IF(QSGW_BSE)HdiagIP(sind) = evals2(condind)-evals(valind)
       IF(.not.QSGW_BSE)HdiagIP(sind) = E_GWZ(k_ind,condind,is2)-
     .          E_GWZ(k_ind,valind,is)
        rho0t=0

       do ind1=1, 3

       IF(NL_fieldcorr)THEN
            rho0t = rho0t + rho0t2(ind1)*
     &                   optmt2(ind1,valind,condind,is2,k_ind)/
     &                   (EDFT(k_ind,valind,is)-EDFT(k_ind,condind,is2))
C NOTE! Need to change the index to account for q\=0, however we can
C only read optmt2 for q=0.
        ELSE
           IF(QSGW_BSE)THEN
            rho0t = rho0t + rho0t2(ind1)*optmt2(
     &   ind1,valind,condind,is2,k_ind)/(evals2(valind)-evals(condind))

           ELSE
            rho0t = rho0t + rho0t2(ind1)*
     &                          optmt2(ind1,valind,condind,is2,k_ind)/
     &               (E_GWZ(k_ind,valind,is)-E_GWZ(k_ind,condind,is2))
           ENDIF
        ENDIF
        enddo

         rho0(sind) = zimag * rho0t     ! Goes up to Hmax

            end do
            end do

C---------------------------------------------------------------------
      Hmax_ini= Hmax+numkpts*((nemup-cond_default_stsp(1)+1)*
     .                  (valn_default_stsp(1)-nfilo))
      if(nspin==2)Hmax_ini= Hmax_ini+numkpts*(
     .     (nemup-cond_default_stsp(2)+1)*(valn_default_stsp(2)-nfilo))

            do valind = valn_default_stsp(is), valn_default_endsp(is)
              do condind = cond_default_endsp(is)+1,nemup
               sind =Hmax_ini+
     .    (is-1)*numkpts*(valn_default_endsp(1)-valn_default_stsp(1)+1)*
     .          (nemup-cond_default_endsp(1))+(k_indfbz-1)*
     .          (valn_default_endsp(is)-valn_default_stsp(is)+1)*
     .    (nemup-cond_default_endsp(is))+(valind-valn_default_stsp(is))*
     .    (nemup-cond_default_endsp(is))+condind-cond_default_endsp(is)
C Spin-flip?
C            sind = Hmax+numkpts*nspin*nspin*nempm*(valn_default_st-1)+
C     .        (k_indfbz-1)*nspin*nspin*num_valn*(nempm-num_cond_states)
C     .          +(is-1)*num_valn*(nempm-num_cond_states)*nspin+
C     .          (is2-1)*num_valn*(nempm-num_cond_states)
C     .          +(valind-valn_default_st)*(nempm-num_cond_states) +
C     .          condind-cond_default_end
        occdiffIP(sind) = occs(k_indfbz,is2,condind)-
     .          occs(k_indfbz,is,valind)
       IF(QSGW_BSE)HdiagIP(sind) = evals2(condind)-evals(valind)
        IF(.not.QSGW_BSE)HdiagIP(sind) = E_GWZ(k_ind,condind,is2)-
     .          E_GWZ(k_ind,valind,is)

        rho0t=0

        do ind1=1, 3

        IF(NL_fieldcorr)THEN
            rho0t = rho0t + rho0t2(ind1)*
     &                   optmt2(ind1,valind,condind,is2,k_ind)/
     &                   (EDFT(k_ind,valind,is)-EDFT(k_ind,condind,is2))
        ELSE
           IF(QSGW_BSE)THEN
            rho0t = rho0t + rho0t2(ind1)*optmt2(
     &   ind1,valind,condind,is2,k_ind)/(evals2(valind)-evals(condind))

           ELSE
            rho0t = rho0t + rho0t2(ind1)*
     &                          optmt2(ind1,valind,condind,is2,k_ind)/
     &               (E_GWZ(k_ind,valind,is)-E_GWZ(k_ind,condind,is2))
           ENDIF
        ENDIF
        enddo

         rho0(sind) = zimag * rho0t     ! Goes up to Hmax
            end do
            end do

         end do

C Spin-flip
C         enddo
         end do

         end do
      deallocate(optmt2)
      IF(NL_fieldcorr)deallocate(EDFT)

      write(*,*)'optical matrix determined'
      allocate(absorp(1:numomega))
      allocate(real_eps(1:numomega))

      allocate(tmp1(Hmax2))
      write(*,*)'Sum over the variable S prime'
      IF(.NOT.Independent_particle)THEN

      allocate(tmp3(Hmax2))
      do lambindp = 1, Hmax2
        sum_overSp = 0d0
        do sindp = 1, Hmax2
           if(sindp <= Hmax)then
           sum_overSp = sum_overSp - occdiff(sindp)*    ! -occdiff, cancels below!
     .             dconjg(EigvecH(sindp,lambindp,1))*dconjg(rho0(sindp))
           else
           sum_overSp = sum_overSp - occdiff(sindp-Hmax)*       ! Two minus signs cancel here
     .             dconjg(EigvecH(sindp,lambindp,1))*rho0(sindp-Hmax)
           endif
        enddo
           tmp3(lambindp) = sum_overSp
      enddo

      ENDIF

      write(*,*)'Sum over the variable S and lambda prime'
      do lambind = 1, Hmax2
        IF(.NOT.Independent_particle)THEN
        sum_overS = 0d0
        do sind = 1, Hmax2
             if(sind <= Hmax)then
             sum_overS = sum_overS +
     .              (rho0(sind))*eigvecH(sind,lambind,1)
           else
             sum_overS = sum_overS -
     .                  dconjg(rho0(sind-Hmax))*eigvecH(sind,lambind,1)
             endif
        enddo

        ELSE
        sum_overS = -occdiff(lambind)*rho0(lambind)
        ENDIF
        if(Hermit_H)then
          IF(.NOT.Independent_particle)THEN
          tmp1(lambind) = sum_overS * tmp3(lambind)
          ELSE
          tmp1(lambind) = sum_overS * dconjg(rho0(lambind))
          ENDIF
        else ! Won't have non-Hermitian H in independent particle case
          sum_overlp = 0d0
          do lambindp = 1, Hmax2
           sum_overlp = sum_overlp +
     .       sum_overS * tmp3(lambindp) * overlapH_inv(lambind,lambindp)
          enddo
          tmp1(lambind) = sum_overlp
        endif
      enddo
      IF(.NOT.Independent_particle)deallocate(tmp3)
      img_frqs=1
      nw_min=1
        fac1=1.0d0
        fac2=1.0d0
C----------------------------------------------------------------------------
C IGNORE the stuff below to the dashed lines
C----------------------------------------------------------------------------
      if(switchr==1.or.switchr==2)img_frqs=2
      DO ind3 = 1, img_frqs
      if(ind3==1.and.switchr>0)then
      open(UNIT=3111,file='freq_r')
      read(3111,*) nwp, nw_i
      deallocate(omega)
      allocate(omega(0:nwp-1))
         do ind1 =  nw_i, -1
          read(3111,*) omega(-ind1),ind2
          omega(-ind1)=-omega(-ind1)
        enddo
        do ind1= 0, nwp-1
          read(3111,*) omega(ind1),ind2
        enddo
      CLOSE(3111)
      if(switchr==1)OPEN(unit=3124,file='eps_11R')
      if(switchr==2)OPEN(unit=3124,file='eps_11RBSE')
      call getkeyvalue("GWinput","omg_c",omg_c)
C      do  iw = 1, nwp           !linear + quadratic term
C        omega(iw-1) = dw*(iw-1) + dw**2/2/omg_c*(iw-1)**2
C      enddo

      numomega = nwp-1 ! CHECK!
      nw_min =  nw_i

      Max_omega = omega(nwp-1)
      Min_omega = omega(nw_i)
      fac2=0.5d0
      ELSEIF(ind3==2)THEN
        deallocate(omega)
        nw_min = 1
       allocate(omega(niw),freqx(niw),wx(niw),expa(niw) )
       call freq01 (niw,ua,freqx,omega,wx,expa)
       deallocate(freqx,wx,expa)
        numomega = niw
        fac2=0.5d0
        fac1=zimag
        if(switchr==1)OPEN(unit=3124,file='eps_11I')
        if(switchr==2)OPEN(unit=3124,file='eps_11IBSE')
      ENDIF
C----------------------------------------------------------------
C Ignored to here!
C---------------------------------------------------------------
      do wind = nw_min,numomega
C        write(*,*)'Energy point ',wind,' of ','numomega'
        ImagE=(imagE2-ImagE1)/(Max_omega-min_omega)*omega(wind)+
     .        (ImagE1*max_omega-min_omega*ImagE2)/(max_omega-min_omega)

        if(ind3==2)ImagE=0.0d0
        if(ind3==1.and.switchr>0)ImagE=0.5d0*ImagE
        sumabsorp = 0d0
        do lambind = 1, Hmax2
C Below, we have a linearly dependent damping, where the inputs give the
C lower upper bound to the damping, and this varies linearly with
C energy!
          IF(Independent_particle)THEN
         IF(Gauss_BSE)then
          sumabsorp = sumabsorp -(tmp1(lambind))*(
     . (fac1*omega(wind)-fac2*Hdiag(lambind))/
     . ((fac1*omega(wind)-fac2*Hdiag(lambind))**2+image**2)-
     . (fac1*omega(wind)+fac2*Hdiag(lambind))/
     . ((fac1*omega(wind)+fac2*Hdiag(lambind))**2+image**2)
     .      - zimag/image*
     .(exp(-(fac1*omega(wind)-fac2*Hdiag(lambind))**2/
     .  (2.0d0*image**2))+
     . exp(-(fac1*omega(wind)+fac2*Hdiag(lambind))**2/
     .(2.0d0*image**2))))

         ELSE
         sumabsorp = sumabsorp -(tmp1(lambind))*(
     .          1d0/(fac1*omega(wind)-fac2*Hdiag(lambind)+zimag*ImagE)-
     .          1d0/(fac1*omega(wind)+fac2*Hdiag(lambind)-zimag*ImagE))
C     .                  (Hdiag(lambind)-omega(wind)+zimag*ImagE)
         ENDIF
          ELSE
          IF(Gauss_BSE)then
          sumabsorp = sumabsorp -(tmp1(lambind))*(
     . (fac1*omega(wind)-fac2*eigvalh(lambind,1))/
     . ((fac1*omega(wind)-fac2*eigvalh(lambind,1))**2+image**2)-
     . (fac1*omega(wind)+fac2*eigvalh(lambind,1))/
     . ((fac1*omega(wind)+fac2*eigvalh(lambind,1))**2+image**2)
     .      - zimag/image*
     .(exp(-(fac1*omega(wind)-fac2*eigvalh(lambind,1))**2/
     .  (2.0d0*image**2))+
     . exp(-(fac1*omega(wind)+fac2*eigvalh(lambind,1))**2/
     .(2.0d0*image**2))))

          ELSE
          sumabsorp = sumabsorp -(tmp1(lambind))*(
     .         1d0/(fac1*omega(wind)-fac2*eigvalH(lambind,1)+zimag*
     .                  ImagE)-
     .         1d0/(fac1*omega(wind)+fac2*eigvalH(lambind,1)-zimag*
     .                  ImagE))
C     .                  (EigvalH(lambind)-omega(wind)+zimag*ImagE)

          ENDIF
        ENDIF
        enddo
        if(switchr>0)cycle! Below adds independent transitions to optical spectra
        DO lambind = Hmax+1,Hmax_opt ! Spin-flip, nspin?

         IF(Gauss_BSE)then
         sumabsorp = sumabsorp -(-occdiffIP(lambind)*(dconjg(rho0(
     .   lambind))*rho0(lambind)))*(
     . (fac1*omega(wind)-HdiagIP(lambind))/
     . ((fac1*omega(wind)-HdiagIP(lambind))**2+ImagE**2)-
     . (fac1*omega(wind)+HdiagIP(lambind))/
     . ((fac1*omega(wind)+HdiagIP(lambind))**2+ImagE**2)
     .      - zimag/ImagE*
     .(exp(-(fac1*omega(wind)-HdiagIP(lambind))**2/
     .  (2.0d0*ImagE**2))+
     . exp(-(fac1*omega(wind)+HdiagIP(lambind))**2/
     .(2.0d0*ImagE**2))))
         ELSE
         sumabsorp = sumabsorp -(-occdiffIP(lambind)*(dconjg(rho0(
     .   lambind))*rho0(lambind)))*(
     .          1d0/(omega(wind)-HdiagIP(lambind)+zimag*ImagE)-
     .          1d0/(omega(wind)+HdiagIP(lambind)-zimag*ImagE))

          ENDIF
        ENDDO
C        if(nspin==2)sumabsorp = sumabsorp*0.5d0
        absorp(wind) = imag(sumabsorp)
        real_eps(wind) = real(sumabsorp)
      enddo
        if(switchr>0)CLOSE(3124)
      ENDDO
      write(*,*)'End loop over frequencies'
      deallocate(tmp1)

       IF(Independent_particle)deallocate(Hdiag)
      IF(switchr <= 0)THEN
      fpi_o_vol = fpi / cell_vol ! change to a + due to the -i*-i from rho!
      absorp = absorp * 8.0d0*fpi_o_vol/nqbz ! 8 comes from the conversion to Atomic units!
      real_eps = real_eps * 8.0d0*fpi_o_vol/nqbz+1.0d0 ! 8 comes from the conversion to Atomic units!

      absorp_file = 8976
      if (rank == 0)then
        open(absorp_file,file='eps_BSE.out')
       write(absorp_file,*)'#Independent Particle',Independent_particle
        write(absorp_file,*)'#Numkpts,nspin=',nqbz,nspin
        Do ind1=1,nspin
        write(absorp_file,*)'#spin=',ind1
        write(absorp_file,*)'#Number of BSE conduction states=',
     .          num_cond_statessp(ind1)
        write(absorp_file,*)'#Number of BSE valence
     .          states=',num_valnsp(ind1)
        enddo
        write(absorp_file,*)'#Total number of val/cond states=',
     .          nfilm,nempm
        write(absorp_file,*)'#Gaussian broadening=',Gauss_BSE
       write(absorp_file,*)'#If not Gaussian broadening then Lorentzian'
        write(absorp_file,*)'#Broadenings=',ImagE1,ImagE2
        write(absorp_file,*)'#LDA energies used as N.L. potential
     . correction in BSE program and NOT lmf',NL_fieldcorr
        write(absorp_file,*)'#direction of q-vector='
        write(absorp_file,*)'#',qvec
        write(absorp_file,*)'#Energy(eV),Real(eps),Imag(eps)'
          do i=1, numomega
            write(absorp_file,*)omega(i)*rydberg(),real_eps(i),absorp(i)
          end do
        close(absorp_file)
      endif
      ENDIF
 135  continue
      IF(QSGW_BSE)deallocate(evals,evals2)
      IF(.NOT.QSGW_BSE)deallocate(E_GWZ)
      if(allocated(overlapH_inv))deallocate(overlapH_inv)
      deallocate(ibzx)
      IF(.NOT.Independent_particle.and.opt_abs)deallocate(eigvalH,
     .          eigvecH)
      deallocate(occdiff)
      if(opt_abs)deallocate(rho0,omega,absorp,real_eps,HdiagIP,
     .  occdiffIP)
      deallocate(occs)
      deallocate(iclasst,invgx,miat,tiat,shtvg)
      deallocate(num_val_sp,wqt,q0i)
      deallocate(num_valnsp,num_cond_statessp)
      deallocate(valn_default_stsp,valn_default_endsp,
     .  cond_default_stsp,cond_default_endsp,Smax_sp)
C     close CLASS file!

      call cputid(0)
C      call MPI_Finalize
C      if (nthreads > 1) then
C        print 131, (dwtime() - walltime0)/60, cpusec()/60, nthreads
C      else
C        print 131, (dwtime() - walltime0)/60, cpusec()/60
C      endif
C  131 format(' bethe_salpeter :  Wall clock time',f9.1,'m','  Processor
C     & time',f9.1,'m':,i4,' threads')
C


       if (allocated(absorp             )) deallocate(absorp             )
       if (allocated(eigvalh            )) deallocate(eigvalh            )
       if (allocated(eigvech            )) deallocate(eigvech            )
       if (allocated(eps_inv            )) deallocate(eps_inv            )
       if (allocated(eps_inv2           )) deallocate(eps_inv2           )
       if (allocated(eps_new            )) deallocate(eps_new            )
       if (allocated(epstilde           )) deallocate(epstilde           )
       if (allocated(evals              )) deallocate(evals              )
       if (allocated(evals2             )) deallocate(evals2             )
       if (allocated(evals_opt          )) deallocate(evals_opt          )
       if (allocated(expa               )) deallocate(expa               )
       if (allocated(freq_i             )) deallocate(freq_i             )
       if (allocated(freq_r             )) deallocate(freq_r             )
       if (allocated(freqx              )) deallocate(freqx              )
       if (allocated(hdiag              )) deallocate(hdiag              )
       if (allocated(hdiagip            )) deallocate(hdiagip            )
       if (allocated(ibzx               )) deallocate(ibzx               )
       if (allocated(iclasst            )) deallocate(iclasst            )
       if (allocated(invgx              )) deallocate(invgx              )
       if (allocated(kernel2            )) deallocate(kernel2            )
       if (allocated(miat               )) deallocate(miat               )
       if (allocated(num_cond_statessp  )) deallocate(num_cond_statessp  )
       if (allocated(num_valnsp         )) deallocate(num_valnsp         )
       if (allocated(num_val_sp         )) deallocate(num_val_sp         )
       if (allocated(occdiff            )) deallocate(occdiff            )
       if (allocated(occs               )) deallocate(occs               )
       if (allocated(omega              )) deallocate(omega              )
       if (allocated(optmt              )) deallocate(optmt              )
       if (allocated(optmt2             )) deallocate(optmt2             )
       if (allocated(overlaph_inv       )) deallocate(overlaph_inv       )
       if (allocated(pbar               )) deallocate(pbar               )
       if (allocated(pright             )) deallocate(pright             )
       if (allocated(q0i                )) deallocate(q0i                )
       if (allocated(qp_opt             )) deallocate(qp_opt             )
       if (allocated(real_eps           )) deallocate(real_eps           )
       if (allocated(rho0               )) deallocate(rho0               )
       if (allocated(tmp1               )) deallocate(tmp1               )
       if (allocated(tmp3               )) deallocate(tmp3               )
       if (allocated(valn_default_endsp )) deallocate(valn_default_endsp )
       if (allocated(valn_default_stsp  )) deallocate(valn_default_stsp  )
       if (allocated(vcoud              )) deallocate(vcoud              )
       if (allocated(vcousq             )) deallocate(vcousq             )
       if (allocated(w0                 )) deallocate(w0                 )
       if (allocated(w0i                )) deallocate(w0i                )
       if (allocated(wqt                )) deallocate(wqt                )
       if (allocated(wx                 )) deallocate(wx                 )
       if (allocated(zw                 )) deallocate(zw                 )
       if (allocated(zw2                )) deallocate(zw2                )
       if (allocated(zzmeltppovlz       )) deallocate(zzmeltppovlz       )











      end program
